{"service_name":"travis-ci","service_job_id":"10938502","git":{"branch":"(detached from 4cfaf1f)","head":{"id":"4cfaf1fc7d7b7fb5846b306259a4c1f02e47483e","author_name":"Erin Millard","author_email":"ezzatron@gmail.com","committer_name":"Erin Millard","committer_email":"ezzatron@gmail.com","message":"Code style fixes."},"remotes":[{"name":"origin","url":"git:\/\/github.com\/eloquent\/pops.git"}]},"run_at":"2013-09-03 15:25:45 +0000","source_files":[{"name":"Eloquent\/Pops\/Proxy.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops;\n\nuse Eloquent\\Pops\\Safe\\SafeInterface;\nuse ReflectionClass;\n\n\/**\n * A transparent proxy.\n *\/\nclass Proxy\n{\n    \/**\n     * Wrap the supplied value in a proxy.\n     *\n     * @param mixed        $value     The value to wrap.\n     * @param boolean|null $recursive True if the value should be recursively proxied.\n     *\n     * @return ProxyInterface The proxied value.\n     *\/\n    public static function proxy($value, $recursive = null)\n    {\n        if ($value instanceof SafeInterface) {\n            return $value;\n        }\n        if (is_object($value)) {\n            return static::proxyObject($value, $recursive);\n        }\n        if (is_array($value)) {\n            return static::proxyArray($value, $recursive);\n        }\n\n        return static::proxyPrimitive($value);\n    }\n\n    \/**\n     * Wrap the supplied array in a proxy.\n     *\n     * @param array        $array     The array to wrap.\n     * @param boolean|null $recursive True if the array should be recursively proxied.\n     *\n     * @return ProxyArray The proxied array.\n     *\/\n    public static function proxyArray($array, $recursive = null)\n    {\n        $class = new ReflectionClass(static::proxyArrayClass());\n\n        return $class->newInstanceArgs(func_get_args());\n    }\n\n    \/**\n     * Wrap the supplied class in a non-static proxy.\n     *\n     * @param string       $class     The name of the class to wrap.\n     * @param boolean|null $recursive True if the class should be recursively proxied.\n     *\n     * @return ProxyClass The non-static class proxy.\n     *\/\n    public static function proxyClass($class, $recursive = null)\n    {\n        $proxyClassClass = new ReflectionClass(static::proxyClassClass());\n\n        return $proxyClassClass->newInstanceArgs(func_get_args());\n    }\n\n    \/**\n     * Wrap the supplied class in a static proxy.\n     *\n     * @param string       $class      The name of the class to wrap.\n     * @param boolean|null $recursive  True if the class should be recursively proxied.\n     * @param string       $proxyClass\n     *\n     * @return string The static class proxy.\n     *\/\n    public static function proxyClassStatic(\n        $class,\n        $recursive = null,\n        $proxyClass = null\n    ) {\n        $method = static::proxyClassClass() . '::popsGenerateStaticClassProxy';\n\n        return call_user_func_array($method, func_get_args());\n    }\n\n    \/**\n     * Wrap the supplied object in a proxy.\n     *\n     * @param object       $object    The object to wrap.\n     * @param boolean|null $recursive True if the object should be recursively proxied.\n     *\n     * @return ProxyObject The proxied object.\n     *\/\n    public static function proxyObject($object, $recursive = null)\n    {\n        $class = new ReflectionClass(static::proxyObjectClass());\n\n        return $class->newInstanceArgs(func_get_args());\n    }\n\n    \/**\n     * Wrap the supplied primitive value in a proxy.\n     *\n     * @param mixed $primitive The primitive value to wrap.\n     *\n     * @return ProxyPrimitive The proxied value.\n     *\/\n    public static function proxyPrimitive($primitive)\n    {\n        $class = new ReflectionClass(static::proxyPrimitiveClass());\n\n        return $class->newInstanceArgs(func_get_args());\n    }\n\n    \/**\n     * Get the array proxy class.\n     *\n     * @return string The array proxy class.\n     *\/\n    protected static function proxyArrayClass()\n    {\n        return __NAMESPACE__ . '\\ProxyArray';\n    }\n\n    \/**\n     * Get the class proxy class.\n     *\n     * @return string The class proxy class.\n     *\/\n    protected static function proxyClassClass()\n    {\n        return __NAMESPACE__ . '\\ProxyClass';\n    }\n\n    \/**\n     * Get the object proxy class.\n     *\n     * @return string The object proxy class.\n     *\/\n    protected static function proxyObjectClass()\n    {\n        return __NAMESPACE__ . '\\ProxyObject';\n    }\n\n    \/**\n     * Get the proxy class for primitive values.\n     *\n     * @return string The proxy class for primitive values.\n     *\/\n    protected static function proxyPrimitiveClass()\n    {\n        return __NAMESPACE__ . '\\ProxyPrimitive';\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,2,null,3,3,null,2,1,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"Eloquent\/Pops\/ProxyArray.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops;\n\nuse ArrayAccess;\nuse ArrayIterator;\nuse Countable;\nuse Iterator;\n\n\/**\n * A transparent array proxy.\n *\/\nclass ProxyArray implements ProxyInterface, ArrayAccess, Countable, Iterator\n{\n    \/**\n     * Construct a new array proxy.\n     *\n     * @param array        $array     The array to wrap.\n     * @param boolean|null $recursive True if the array should be recursively proxied.\n     *\/\n    public function __construct(array $array, $recursive = null)\n    {\n        if (null === $recursive) {\n            $recursive = false;\n        }\n\n        $this->popsArray = $array;\n        $this->popsRecursive = $recursive;\n        $this->popsInnerIterator = new ArrayIterator($this->popsArray);\n    }\n\n    \/**\n     * Get the wrapped array.\n     *\n     * @return array The wrapped array.\n     *\/\n    public function popsArray()\n    {\n        return $this->popsArray;\n    }\n\n    \/**\n     * Set the value of an array index.\n     *\n     * @param integer|string $index The index to set.\n     * @param mixed          $value The new value.\n     *\/\n    public function offsetSet($index, $value)\n    {\n        $this->popsArray[$index] = $value;\n    }\n\n    \/**\n     * Get the value of an array index.\n     *\n     * @param integer|string $index The index to get.\n     *\n     * @return mixed The value.\n     *\/\n    public function offsetGet($index)\n    {\n        return $this->popsProxySubValue($this->popsArray[$index]);\n    }\n\n    \/**\n     * Returns true if the specified array index exists.\n     *\n     * @param integer|string $index The index to search for.\n     *\n     * @return boolean True if the index exists.\n     *\/\n    public function offsetExists($index)\n    {\n        return isset($this->popsArray[$index]);\n    }\n\n    \/**\n     * Remove an array index.\n     *\n     * @param integer|string $index The index to remove.\n     *\/\n    public function offsetUnset($index)\n    {\n        unset($this->popsArray[$index]);\n    }\n\n    \/**\n     * Get the number of elements in the array.\n     *\n     * @return integer The number of elements.\n     *\/\n    public function count()\n    {\n        return count($this->popsArray);\n    }\n\n    \/**\n     * Get the current iterator value.\n     *\n     * @return mixed The current value.\n     *\/\n    public function current()\n    {\n        return $this->popsProxySubValue(\n            $this->popsInnerIterator->current()\n        );\n    }\n\n    \/**\n     * Get the current iterator key.\n     *\n     * @return mixed The current key.\n     *\/\n    public function key()\n    {\n        return $this->popsInnerIterator->key();\n    }\n\n    \/**\n     * Move to the next iterator value.\n     *\/\n    public function next()\n    {\n        $this->popsInnerIterator->next();\n    }\n\n    \/**\n     * Rewind to the beginning of the iterator.\n     *\/\n    public function rewind()\n    {\n        $this->popsInnerIterator->rewind();\n    }\n\n    \/**\n     * Returns true if the current iterator position is valid.\n     *\n     * @return boolean True if the current position is valid.\n     *\/\n    public function valid()\n    {\n        return $this->popsInnerIterator->valid();\n    }\n\n    \/**\n     * Get the string representation of this array.\n     *\n     * @return string The string representation.\n     *\/\n    public function __toString()\n    {\n        return strval($this->popsProxySubValue(strval($this->popsArray)));\n    }\n\n    \/**\n     * Get the proxy class.\n     *\n     * @return string The proxy class.\n     *\/\n    protected static function popsProxyClass()\n    {\n        return __NAMESPACE__ . '\\Proxy';\n    }\n\n    \/**\n     * Wrap a sub-value in a proxy if recursive proxying is enabled.\n     *\n     * @param mixed $value The value to wrap.\n     *\n     * @return mixed The proxied value, or the untouched value.\n     *\/\n    protected function popsProxySubValue($value)\n    {\n        if ($this->popsRecursive) {\n            $popsClass = static::popsProxyClass();\n\n            return $popsClass::proxy($value, true);\n        }\n\n        return $value;\n    }\n\n    private $popsArray;\n    private $popsRecursive;\n    private $popsInnerIterator;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,5,5,null,5,5,5,5,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,3,3,null,3,null,null,3,null,null,null,null,null,null]},{"name":"Eloquent\/Pops\/ProxyClass.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops;\n\nuse LogicException;\n\n\/**\n * A transparent class proxy.\n *\/\nclass ProxyClass implements ProxyInterface\n{\n    \/**\n     * Call a method on this class proxy.\n     *\n     * @param string $method    The name of the method to call.\n     * @param array  $arguments The arguments.\n     *\n     * @return mixed The result of the method call.\n     *\/\n    public static function __callStatic($method, array $arguments)\n    {\n        return static::popsProxySubValue(\n            call_user_func_array(\n                array(static::popsProxy(), $method),\n                $arguments\n            ),\n            static::$popsStaticRecursive\n        );\n    }\n\n    \/**\n     * Get the non-static class proxy for this class.\n     *\n     * @return ProxyClass The non-static class proxy.\n     *\/\n    public static function popsProxy()\n    {\n        $originalClass = static::$popsStaticOriginalClass;\n        if (null === $originalClass) {\n            throw new LogicException(\n                'This class should not be called directly.'\n            );\n        }\n\n        $proxyClassClass = get_called_class();\n\n        if (\n            !isset(self::$popsStaticProxies[$proxyClassClass][$originalClass])\n        ) {\n            self::$popsStaticProxies[$proxyClassClass][$originalClass] =\n                new $proxyClassClass($originalClass);\n        }\n\n        return self::$popsStaticProxies[$proxyClassClass][$originalClass];\n    }\n\n    \/**\n     * Generate and load a static class proxy.\n     *\n     * @param string       $class      The name of the class to proxy.\n     * @param boolean|null $recursive  True if the proxy should be recursive.\n     * @param string|null  $proxyClass The class name to use for the proxy class.\n     *\n     * @return string The class name used for the procy class.\n     *\/\n    public static function popsGenerateStaticClassProxy(\n        $class,\n        $recursive = null,\n        $proxyClass = null\n    ) {\n        if (null === $recursive) {\n            $recursive = false;\n        }\n\n        $classDefinition = static::popsStaticClassProxyDefinition(\n            $class,\n            $recursive,\n            $proxyClass\n        );\n        eval($classDefinition);\n\n        return $proxyClass;\n    }\n\n    \/**\n     * Construct a new non-static class proxy.\n     *\n     * @param string       $class     The name of the class to proxy.\n     * @param boolean|null $recursive True if the proxy should be recursive.\n     *\/\n    public function __construct($class, $recursive = null)\n    {\n        if (null === $recursive) {\n            $recursive = false;\n        }\n\n        $this->popsClass = $class;\n        $this->popsRecursive = $recursive;\n    }\n\n    \/**\n     * Get the name of the proxied class.\n     *\n     * @return string The proxied class name.\n     *\/\n    public function popsClass()\n    {\n        return $this->popsClass;\n    }\n\n    \/**\n     * Call a static method on the proxied class with support for by-reference\n     * arguments.\n     *\n     * @param string $method     The name of the method to call.\n     * @param array  &$arguments The arguments.\n     *\n     * @return mixed The result of the method call.\n     *\/\n    public function popsCall($method, array &$arguments)\n    {\n        return static::popsProxySubValue(\n            call_user_func_array($this->popsClass . '::' . $method, $arguments),\n            $this->popsRecursive\n        );\n    }\n\n    \/**\n     * Call a static method on the proxied class.\n     *\n     * @param string $method    The name of the method to call.\n     * @param array  $arguments The arguments.\n     *\n     * @return mixed The result of the method call.\n     *\/\n    public function __call($method, array $arguments)\n    {\n        return $this->popsCall($method, $arguments);\n    }\n\n    \/**\n     * Set the value of a static property on the proxied class.\n     *\n     * @param string $property The name of the property to set.\n     * @param mixed  $value    The new value.\n     *\/\n    public function __set($property, $value)\n    {\n        $class = $this->popsClass;\n        $class::$$property = $value;\n    }\n\n    \/**\n     * Get the value of a static property on the proxied class.\n     *\n     * @param string $property The name of the property to get.\n     *\n     * @return mixed The value of the property.\n     *\/\n    public function __get($property)\n    {\n        $class = $this->popsClass;\n\n        return static::popsProxySubValue(\n            $class::$$property,\n            $this->popsRecursive\n        );\n    }\n\n    \/**\n     * Returns true if the supplied static property exists on the proxied class.\n     *\n     * @param string $property The name of the property to search for.\n     *\n     * @return boolean True if the property exists.\n     *\/\n    public function __isset($property)\n    {\n        $class = $this->popsClass;\n\n        return isset($class::$$property);\n    }\n\n    \/**\n     * Set the value of a static property on the proxied class to null.\n     *\n     * @param string $property The name of the property to set.\n     *\/\n    public function __unset($property)\n    {\n        $class = $this->popsClass;\n\n        $class::$$property = null;\n    }\n\n    \/**\n     * Get the proxy class.\n     *\n     * @return string The proxy class.\n     *\/\n    protected static function popsProxyClass()\n    {\n        return __NAMESPACE__ . '\\Proxy';\n    }\n\n    \/**\n     * Wrap a sub-value in a proxy if recursive proxying is enabled.\n     *\n     * @param mixed   $value     The value to wrap.\n     * @param boolean $recursive True if recursive proxying is enabled.\n     *\n     * @return mixed The proxied value, or the untouched value.\n     *\/\n    protected static function popsProxySubValue($value, $recursive)\n    {\n        if ($recursive) {\n            $popsClass = static::popsProxyClass();\n\n            return $popsClass::proxy($value, true);\n        }\n\n        return $value;\n    }\n\n    \/**\n     * Generate a static class proxy definition.\n     *\n     * @param string      $class       The name of the class to proxy.\n     * @param boolean     $recursive   True if the proxy should be recursive.\n     * @param string|null &$proxyClass The class name to use for the proxy class.\n     *\n     * @return string The proxy class definition.\n     *\/\n    protected static function popsStaticClassProxyDefinition(\n        $originalClass,\n        $recursive,\n        &$proxyClass\n    ) {\n        $proxyClass = static::popsStaticClassProxyDefinitionProxyClass(\n            $originalClass,\n            $proxyClass\n        );\n\n        return sprintf(\n            '%s { %s }',\n            static::popsStaticClassProxyDefinitionHeader($proxyClass),\n            static::popsStaticClassProxyDefinitionBody(\n                $originalClass,\n                $recursive\n            )\n        );\n    }\n\n    \/**\n     * Generate a static class proxy class name, or return the supplied name.\n     *\n     * @param string      $originalClass The name of the class being proxied.\n     * @param string|null $proxyClass    The class name to use for the proxy class.\n     *\n     * @return string The proxy class name.\n     *\/\n    protected static function popsStaticClassProxyDefinitionProxyClass(\n        $originalClass,\n        $proxyClass\n    ) {\n        if (null === $proxyClass) {\n            $originalClassParts = explode('\\\\', $originalClass);\n            $proxyClassPrefix = array_pop($originalClassParts) . '_Pops_';\n            $proxyClassNamespace = implode('\\\\', $originalClassParts);\n            $proxyClass = uniqid($proxyClassPrefix);\n            if ($proxyClassNamespace) {\n                $proxyClass = sprintf(\n                    '%s\\\\%s',\n                    $proxyClassNamespace,\n                    $proxyClass\n                );\n            }\n        }\n\n        return $proxyClass;\n    }\n\n    \/**\n     * Generate the class header for a static class proxy class.\n     *\n     * @param string $proxyClass The class name to use for the proxy class.\n     *\n     * @return string The static class proxy class header.\n     *\/\n    protected static function popsStaticClassProxyDefinitionHeader($proxyClass)\n    {\n        $proxyClassParts = explode('\\\\', $proxyClass);\n        $proxyClass = array_pop($proxyClassParts);\n        $proxyClassNamespace = implode('\\\\', $proxyClassParts);\n\n        $header = sprintf(\n            'class %s extends \\\\%s',\n            $proxyClass,\n            get_called_class()\n        );\n        if ($proxyClassNamespace) {\n            $header = sprintf(\n                'namespace %s; %s',\n                $proxyClassNamespace,\n                $header\n            );\n        }\n\n        return $header;\n    }\n\n    \/**\n     * Generate the class body for a static class proxy class.\n     *\n     * @param string  $originalClass The name of the class being proxied.\n     * @param boolean $recursive     True if the proxy should be recursive.\n     *\n     * @return string The static class proxy class body.\n     *\/\n    protected static function popsStaticClassProxyDefinitionBody(\n        $originalClass,\n        $recursive\n    ) {\n        return sprintf(\n            'protected static $popsStaticOriginalClass = %s; ' .\n                'protected static $popsStaticRecursive = %s;',\n            var_export($originalClass, true),\n            var_export($recursive, true)\n        );\n    }\n\n    private static $popsStaticOriginalClass;\n    private static $popsStaticRecursive;\n    private static $popsStaticProxies = array();\n    private $popsClass;\n    private $popsRecursive;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,2,2,null,1,null,1,null,null,null,null,null,null,null,null,null,2,2,1,null,1,null,null,1,null,null,1,1,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,null,1,1,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,null,6,6,6,null,6,6,6,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,3,3,3,3,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,1,1,1,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,4,3,null,3,null,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,1,null,1,1,1,1,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,1,1,1,1,1,1,null,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,1,1,1,null,1,1,1,1,1,1,1,1,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pops\/ProxyInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops;\n\n\/**\n * The interface used to identify proxied values.\n *\/\ninterface ProxyInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pops\/ProxyObject.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops;\n\nuse ArrayAccess;\nuse BadMethodCallException;\nuse Countable;\nuse InvalidArgumentException;\nuse Iterator;\nuse IteratorAggregate;\nuse LogicException;\n\n\/**\n * A transparent object proxy.\n *\/\nclass ProxyObject implements ProxyInterface, ArrayAccess, Countable, Iterator\n{\n    \/**\n     * Construct a new object proxy.\n     *\n     * @param object       $object    The object to wrap.\n     * @param boolean|null $recursive True if the object should be recursively proxied.\n     *\/\n    public function __construct($object, $recursive = null)\n    {\n        if (!is_object($object)) {\n            throw new InvalidArgumentException(\n                'Provided value is not an object'\n            );\n        }\n\n        if (null === $recursive) {\n            $recursive = false;\n        }\n        if (!is_bool($recursive)) {\n            throw new InvalidArgumentException(\n                'Provided value is not a boolean'\n            );\n        }\n\n        $this->popsObject = $object;\n        $this->popsRecursive = $recursive;\n    }\n\n    \/**\n     * Get the wrapped object.\n     *\n     * @return object The wrapped object.\n     *\/\n    public function popsObject()\n    {\n        return $this->popsObject;\n    }\n\n    \/**\n     * Call a method on the wrapped object with support for by-reference\n     * arguments.\n     *\n     * @param string $method     The name of the method to call.\n     * @param array  &$arguments The arguments.\n     *\n     * @return mixed The result of the method call.\n     *\/\n    public function popsCall($method, array &$arguments)\n    {\n        return $this->popsProxySubValue(\n            call_user_func_array(array($this->popsObject, $method), $arguments)\n        );\n    }\n\n    \/**\n     * Call a method on the wrapped object.\n     *\n     * @param string $method    The name of the method to call.\n     * @param array  $arguments The arguments.\n     *\n     * @return mixed The result of the method call.\n     *\/\n    public function __call($method, array $arguments)\n    {\n        return $this->popsCall($method, $arguments);\n    }\n\n    \/**\n     * Set the value of a property on the wrapped object.\n     *\n     * @param string $property The property name.\n     * @param mixed  $value    The new value.\n     *\/\n    public function __set($property, $value)\n    {\n        $this->popsObject->$property = $value;\n    }\n\n    \/**\n     * Get the value of a property from the wrapped object.\n     *\n     * @param string $property The property name.\n     *\n     * @return mixed The property value.\n     *\/\n    public function __get($property)\n    {\n        return $this->popsProxySubValue(\n            $this->popsObject->$property\n        );\n    }\n\n    \/**\n     * Returns true if the property exists on the wrapped object.\n     *\n     * @param string $property The name of the property to search for.\n     *\n     * @return boolean True if the property exists.\n     *\/\n    public function __isset($property)\n    {\n        return isset($this->popsObject->$property);\n    }\n\n    \/**\n     * Unset a property from the wrapped object.\n     *\n     * @param string $property The property name.\n     *\/\n    public function __unset($property)\n    {\n        unset($this->popsObject->$property);\n    }\n\n    \/**\n     * Set a value on the wrapped object using the ArrayAccess interface.\n     *\n     * @param string $key   The key to set.\n     * @param mixed  $value The new value.\n     *\/\n    public function offsetSet($key, $value)\n    {\n        $this->__call('offsetSet', func_get_args());\n    }\n\n    \/**\n     * Get a value from the wrapped object using the ArrayAccess interface.\n     *\n     * @param string $key The key to get.\n     *\n     * @return mixed The value.\n     *\/\n    public function offsetGet($key)\n    {\n        return $this->__call('offsetGet', func_get_args());\n    }\n\n    \/**\n     * Returns true if the supplied key exists on the wrapped object according\n     * to the ArrayAccess interface.\n     *\n     * @param string $key The key to search for.\n     *\n     * @return boolean True if the key exists.\n     *\/\n    public function offsetExists($key)\n    {\n        return $this->__call('offsetExists', func_get_args());\n    }\n\n    \/**\n     * Remove a key from the wrapped object using the ArrayAccess interface.\n     *\n     * @param string $key The key to remove.\n     *\/\n    public function offsetUnset($key)\n    {\n        $this->__call('offsetUnset', func_get_args());\n    }\n\n    \/**\n     * Return the result of the wrapped object's count method.\n     *\n     * @return integer The wrapped object's count.\n     *\/\n    public function count()\n    {\n        return $this->__call('count', array());\n    }\n\n    \/**\n     * Get the current iterator value.\n     *\n     * @return mixed The current value.\n     *\/\n    public function current()\n    {\n        return $this->popsProxySubValue($this->popsInnerIterator()->current());\n    }\n\n    \/**\n     * Get the current iterator key.\n     *\n     * @return mixed The current key.\n     *\/\n    public function key()\n    {\n        return $this->popsInnerIterator()->key();\n    }\n\n    \/**\n     * Move to the next iterator value.\n     *\/\n    public function next()\n    {\n        $this->popsInnerIterator()->next();\n    }\n\n    \/**\n     * Rewind to the beginning of the iterator.\n     *\/\n    public function rewind()\n    {\n        $this->popsInnerIterator()->rewind();\n    }\n\n    \/**\n     * Returns true if the current iterator position is valid.\n     *\n     * @return boolean True if the current position is valid.\n     *\/\n    public function valid()\n    {\n        return $this->popsInnerIterator()->valid();\n    }\n\n    \/**\n     * @return string\n     *\/\n    public function __toString()\n    {\n        return strval($this->__call('__toString', array()));\n    }\n\n    \/**\n     * Get the string representation of this object.\n     *\n     * @return string The string representation.\n     *\/\n    public function __invoke()\n    {\n        if (!method_exists($this->popsObject, '__invoke')) {\n            throw new BadMethodCallException(\n                sprintf(\n                    'Call to undefined method %s::__invoke()',\n                    get_class($this->popsObject)\n                )\n            );\n        }\n\n        return $this->popsProxySubValue(\n            call_user_func_array($this->popsObject, func_get_args())\n        );\n    }\n\n    \/**\n     * Get the proxy class.\n     *\n     * @return string The proxy class.\n     *\/\n    protected static function popsProxyClass()\n    {\n        return __NAMESPACE__ . '\\Proxy';\n    }\n\n    \/**\n     * Get an iterator for the wrapped object.\n     *\n     * @return Iterator An iterator for the wrapped object.\n     *\/\n    protected function popsInnerIterator()\n    {\n        if (null !== $this->popsInnerIterator) {\n            return $this->popsInnerIterator;\n        }\n\n        if ($this->popsObject instanceof Iterator) {\n            $this->popsInnerIterator = $this->popsObject;\n        } elseif ($this->popsObject instanceof IteratorAggregate) {\n            $this->popsInnerIterator = $this->popsObject->getIterator();\n        } else {\n            throw new LogicException(\n                'Proxied object is not an instance of Traversable'\n            );\n        }\n\n        return $this->popsInnerIterator;\n    }\n\n    \/**\n     * Wrap a sub-value in a proxy if recursive proxying is enabled.\n     *\n     * @param mixed $value The value to wrap.\n     *\n     * @return mixed The proxied value, or the untouched value.\n     *\/\n    protected function popsProxySubValue($value)\n    {\n        if ($this->popsRecursive) {\n            $popsClass = static::popsProxyClass();\n\n            return $popsClass::proxy($value, true);\n        }\n\n        return $value;\n    }\n\n    private $popsObject;\n    private $popsRecursive;\n    private $popsInnerIterator;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,15,1,null,1,null,null,15,14,14,15,1,null,1,null,null,15,15,15,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,9,9,9,null,null,null,null,null,null,null,null,null,null,null,null,7,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,null,null,2,2,2,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,2,2,null,null,null,null,null,null,3,2,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,2,1,1,1,1,1,1,null,null,1,1,1,null,null,null,null,null,null,null,null,null,5,null,null,null,null,null,null,null,null,null,3,2,null,null,3,2,3,1,1,1,null,1,null,null,2,null,null,null,null,null,null,null,null,null,null,null,10,7,null,7,null,null,9,null,null,null,null,null,null]},{"name":"Eloquent\/Pops\/ProxyPrimitive.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops;\n\n\/**\n * A transparent primitive value proxy.\n *\/\nclass ProxyPrimitive\n{\n    \/**\n     * Construct a new primitive value proxy.\n     *\n     * @param scalar|null $primitive The primitive value to wrap.\n     *\/\n    public function __construct($primitive)\n    {\n        $this->popsPrimitive = $primitive;\n    }\n\n    \/**\n     * Get the wrapped value.\n     *\n     * @return scalar|null The wrapped value.\n     *\/\n    public function popsPrimitive()\n    {\n        return $this->popsPrimitive;\n    }\n\n    \/**\n     * Get the string representation of this value.\n     *\n     * @return string The string representation.\n     *\/\n    public function __toString()\n    {\n        return strval($this->popsPrimitive);\n    }\n\n    private $popsPrimitive;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,2,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,2,null,null,null,null]},{"name":"Eloquent\/Pops\/Safe\/SafeInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops\\Safe;\n\nuse Eloquent\\Pops\\ProxyInterface;\n\n\/**\n * The interface used to identify values that should not be recursively proxied.\n *\/\ninterface SafeInterface extends ProxyInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pops\/Safe\/SafeProxy.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops\\Safe;\n\nuse Eloquent\\Pops\\Proxy;\n\n\/**\n * A proxy for wrapping values to prevent recursive proxying.\n *\/\nclass SafeProxy extends Proxy\n{\n    \/**\n     * Get the array proxy class.\n     *\n     * @return string The array proxy class.\n     *\/\n    protected static function proxyArrayClass()\n    {\n        return __NAMESPACE__ . '\\SafeProxyArray';\n    }\n\n    \/**\n     * Get the class proxy class.\n     *\n     * @return string The class proxy class.\n     *\/\n    protected static function proxyClassClass()\n    {\n        return __NAMESPACE__ . '\\SafeProxyClass';\n    }\n\n    \/**\n     * Get the object proxy class.\n     *\n     * @return string The object proxy class.\n     *\/\n    protected static function proxyObjectClass()\n    {\n        return __NAMESPACE__ . '\\SafeProxyObject';\n    }\n\n    \/**\n     * Get the proxy class for primitive values.\n     *\n     * @return string The proxy class for primitive values.\n     *\/\n    protected static function proxyPrimitiveClass()\n    {\n        return __NAMESPACE__ . '\\SafeProxyPrimitive';\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,5,null,null]},{"name":"Eloquent\/Pops\/Safe\/SafeProxyArray.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops\\Safe;\n\nuse Eloquent\\Pops\\ProxyArray;\n\n\/**\n * An array proxy that prevents recusive proxying.\n *\/\nclass SafeProxyArray extends ProxyArray implements SafeInterface\n{\n    \/**\n     * Get the proxy class.\n     *\n     * @return string The proxy class.\n     *\/\n    protected static function popsProxyClass()\n    {\n        return __NAMESPACE__ . '\\SafeProxy';\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"Eloquent\/Pops\/Safe\/SafeProxyClass.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops\\Safe;\n\nuse Eloquent\\Pops\\ProxyClass;\n\n\/**\n * A class proxy that prevents recusive proxying.\n *\/\nclass SafeProxyClass extends ProxyClass implements SafeInterface\n{\n    \/**\n     * Get the proxy class.\n     *\n     * @return string The proxy class.\n     *\/\n    protected static function popsProxyClass()\n    {\n        return __NAMESPACE__ . '\\SafeProxy';\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"Eloquent\/Pops\/Safe\/SafeProxyObject.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops\\Safe;\n\nuse Eloquent\\Pops\\ProxyObject;\n\n\/**\n * An object proxy that prevents recusive proxying.\n *\/\nclass SafeProxyObject extends ProxyObject implements SafeInterface\n{\n    \/**\n     * Get the proxy class.\n     *\n     * @return string The proxy class.\n     *\/\n    protected static function popsProxyClass()\n    {\n        return __NAMESPACE__ . '\\SafeProxy';\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"Eloquent\/Pops\/Safe\/SafeProxyPrimitive.php","source":"<?php\n\n\/*\n * This file is part of the Pops package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pops\\Safe;\n\nuse Eloquent\\Pops\\ProxyPrimitive;\n\n\/**\n * A proxy for primitives that prevents recusive proxying.\n *\/\nclass SafeProxyPrimitive extends ProxyPrimitive implements SafeInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}